### Rustls CI 벤치
CI 벤치는 최고 수준의 연속 벤치마킹을 위한 하네스입니다.
이는 두 가지 다른 모드에서 정확히 같은 벤치마크를 실행합니다: 명령어 수 모드와 벽시간 모드.
이것은 독창적인 맞춤형 비동기 런타임을 사용하여 이루어집니다.
명령어 수 모드에서는 I/O가 여전히 차단됩니다.
내부적으로, 작업은 단 한 번의 폴에서 완료됩니다.
그런 다음 벽시간 모드에서는 I/O가 실제로 비차단됩니다.
이를통해 공유되는 메모리 버퍼를 시뮬레이션할 수 있습니다.
서버와 클라이언트가 번갈아 폴링됩니다.
이를 통해 CI 벤치는 벤치마크에서 비동기 런타임의 노이즈와 비결정성을 제거할 수 있습니다.

Rustls는 CPU 명령어를 추적하기 위해 [cachegrind][cachegrind]를 선택했습니다.
이 결정은 [Rust 컴파일러의 연속 벤치마킹 솔루션][rustc perf]을 본따 만들었습니다.
명령어 수는 같은 소프트웨어의 두 버전을 비교하는 매우 일관된 방법을 제공합니다.
이로써 CI 벤치는 연속 벤치마킹에 이상적입니다.
그러나 명령어 수 증가의 실제 런타임 비용을 추론할 수는 없습니다.
명령어가 10% 증가하더라도 실행 시간 성능이 10% 증가한다는 것을 의미하지는 않습니다.
그러나 명령어 수의 큰 증가는 런타임 성능이 다소 증가했다는 것을 나타냅니다.
이런 이유로 CI 벤치는 벽시간도 측정합니다.

벽시간은 Rustls 프로젝트가 실제로 신경 쓰는 것입니다.
명령어 수를 측정하는 것은 단지 유용한 프록시일 뿐입니다.
명령어 수 기반 벤치마킹은 같은 수의 명령어를 사용하지만 완전히 다른 벽시간 성능으로 이어지는 변경사항을 구분할 수 없습니다.
예를 들어, 새 알고리즘이 정확히 같은 수의 명령어를 가지지만 두 배 느린 속도로 실행될 수 있습니다.

[cachegrind]: https://valgrind.org/docs/manual/cg-manual.html
[rustc perf]: https://github.com/rust-lang/rustc-perf