### Rustls CI Bench
CI Benchは、連続的なベンチマーク用の最高のハーネスです。
それは、命令数モードと壁時間モードの2つの異なるモードで正確に同じベンチマークを実行します。
これは、独自の巧妙なカスタム非同期ランタイムを使用して実現されます。
命令数モードでは、入出力は実際にはまだブロッキングしています。
内部的には、タスクは単一のポーリングで完了するだけです。
その後、壁時間モードでは入出力は実際に非ブロックです。
これにより、共有メモリバッファのシミュレーションが可能になります。
サーバーとクライアントは交互にポーリングされます。
これにより、CI Benchは非同期ランタイムのノイズと非決定性をベンチマークから排除することができます。

Rustlsは、[cachegrind][cachegrind]を使用してCPU命令を追跡することを選択しました。
この決定は、[Rustコンパイラの連続ベンチマーク解決策][rustc perf]に模範されました。
命令数は、同じソフトウェアの2つのバージョンを比較する非常に一貫した方法を提供します。
これにより、継続的なベンチマークに適しています。
ただし、命令数の増加の実際のランタイムコストを推測することはできません。
命令数が10％増加しても、ランタイム性能が10％増加するわけではありません。
しかし、命令数の大幅な増加は、ランタイム性能がある程度上昇していることを意味します。
このため、CI Benchは壁時間も測定します。

壁時間は、Rustlsプロジェクトが本当に気にしているものです。
命令数の測定は単に便利なプロクシーです。
命令数ベースのベンチマークでは、同じ数の命令を使用するが壁時間性能が大幅に異なる変更を識別できません。 
たとえば、新しいアルゴリズムは偶然にも命令数がまったく同じであるかもしれませんが、実行速度は2倍になるかもしれません。

[cachegrind]: https://valgrind.org/docs/manual/cg-manual.html
[rustc perf]: https://github.com/rust-lang/rustc-perf