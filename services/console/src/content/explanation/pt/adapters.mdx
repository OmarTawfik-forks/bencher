---
title: "Adaptadores de Benchmark"
description: "Use sua ferramenta de benchmark de c√≥digo preferida com os adaptadores integrados do Bencher ou use uma ferramenta de benchmark de c√≥digo personalizada que gera JSON"
heading: "Adaptadores de Ferramenta de Benchmark"
published: "2023-10-27T08:40:00Z"
modified: "2024-03-27T07:50:00Z"
sortOrder: 4
---

import BmfExample from "../../../chunks/explanation/bmf-example.mdx";
import BmfSchema from "../../../chunks/explanation/bmf-schema.mdx";

import RustIaiCallgrind from "../../../chunks/explanation/pt/adapter-rust-iai-callgrind.mdx";

Os adaptadores convertem a sa√≠da da ferramenta de benchmark em JSON padronizado, no Formato de M√©trica do Bencher (BMF).
Os adaptadores s√£o executados no servidor API quando um novo relat√≥rio √© recebido.
Veja a [vis√£o geral do benchmarking](/pt/docs/explanation/benchmarking/) para uma explica√ß√£o mais aprofundada.
Eles podem ser especificados no subcomando <code><a href="/pt/docs/explanation/bencher-run/">bencher run</a></code> CLI com a flag opcional `--adapter`.
Se nenhum adaptador estiver especificado, [o adaptador `magic`](#-magic-default) √© usado por padr√£o.

√â melhor usar o adaptador mais espec√≠fico para o seu caso.
Isso fornecer√° uma an√°lise mais precisa e perform√°tica.
Por exemplo, se voc√™ est√° fazendo parse da sa√≠da do [libtest bench](https://doc.rust-lang.org/rustc/tests/index.html#benchmarks) em Rust
, voc√™ deve usar o adaptador `rust_bench`, e n√£o os adaptadores `magic` ou `rust`.
Veja nossa
[p√°gina de desempenho do Bencher](https://bencher.dev/perf/bencher?key=true&measures=4358146b-b647-4869-9d24-bd22bb0c49b5&tab=benchmarks&testbeds=0d991aac-b241-493a-8b0f-8d41419455d2&branches=619d15ed-0fbd-4ccb-86cb-fddf3124da29&benchmarks=3525f177-fc8f-4a92-bd2f-dda7c4e15699%2C5655ed2a-3e45-4622-bdbd-39cdd9837af8%2C1db23e93-f909-40aa-bf42-838cc7ae05f5&start_time=1674777600000)
para uma boa compara√ß√£o.

## ü™Ñ Magic <small>(padr√£o)</small>

O Adaptador Magic (`magic`) √© um superconjunto de todos os outros adaptadores.
Por esse motivo, √© o adaptador padr√£o para `bencher run`,
mas √© melhor us√°-lo apenas para explora√ß√£o.
No CI, voc√™ deve usar o adaptador mais espec√≠fico para o seu caso.

## \{...\} JSON

O Adaptador JSON (`json`) espera um JSON no formato BMF.
√â perfeito para integrar ferramentas de benchmark personalizadas com o Bencher.

Exemplo de BMF:

<BmfExample />

Neste exemplo, a chave `benchmark_name` seria o nome de um benchmark.
Os nomes do benchmark podem ser qualquer string n√£o vazia de at√© 1024 caracteres.
O objeto `benchmark_name` cont√©m slugs de Tipo de M√©trica ou UUIDs como chaves.
Neste exemplo, `latency` √© o slug para o Tipo de M√©trica Lat√™ncia.
Cada Projeto, por padr√£o, tem um Tipo de M√©trica Lat√™ncia (ou seja, `latency`) e Throughput (ou seja, `throughput`),
que s√£o medidos em `nanossegundo (ns)` e `opera√ß√µes / segundo (ops/s)` respectivamente.
O objeto Tipo de M√©trica cont√©m uma M√©trica com at√© tr√™s medidas: `value`, `lower_value` e `upper_value`.
A `lower_value` e `upper_value` s√£o opcionais,
e seu c√°lculo √© espec√≠fico para a ferramenta de benchmark.

Neste exemplo, o objeto Tipo de M√©trica `latency` cont√©m as seguintes medidas:

- Uma `value` de `88.0`
- Uma `lower_value` de `87.42`
- Uma `upper_value` de `88.88`

Se o JSON BMF estiver armazenado em um arquivo,
ent√£o voc√™ pode usar o subcomando <code><a href="/pt/docs/explanation/bencher-run/">bencher run</a></code> CLI com o argumento opcional `--file` para especificar esse caminho do arquivo.
Isso funciona tanto com um comando de benchmark (ex: `bencher run --file results.json "bencher mock > results.json"`)
quanto sem um comando de benchmark (ex: `bencher mock > results.json && bencher run --file results.json`).

<BmfSchema />

> üê∞ Nota: O subcomando CLI `bencher mock` gera M√©tricas BMF falsas.

## #Ô∏è‚É£ C#

O Adaptador C# (`c_sharp`) √© um superconjunto de `c_sharp_dot_net`.

## #Ô∏è‚É£ C# DotNet

O Adaptador C# DotNet (`c_sharp_dot_net`) espera a sa√≠da do [BenchmarkDotNet](https://github.com/dotnet/BenchmarkDotNet) no [formato JSON (ou seja, `--exporters json`)](https://benchmarkdotnet.org/articles/configs/exporters.html#sample-introexportjson).
A M√©trica de Tipo Lat√™ncia (ou seja, `nanosecond (ns)`) √© coletada.

Existem duas op√ß√µes para a M√©trica:
- `mean` (padr√£o):  A `lower_value` e `upper_value` est√£o uma desvio padr√£o abaixo e acima da m√©dia (ou seja, `value`) respectivamente.
- `median`: A `lower_value` e `upper_value` est√£o um intervalo interquartil abaixo e acima da mediana (ou seja, `value`) respectivamente.

Isso pode ser especificado no subcomando <code><a href="/pt/docs/explanation/bencher-run/">bencher run</a></code> CLI com a flag opcional `--average`.

## ‚ûï C++

O Adaptador C++ (`cpp`) √© um superconjunto de `cpp_catch2` e `cpp_google`.

## ‚ûï C++ Catch2

O Adaptador C++ Catch2 (`cpp_catch2`) espera a sa√≠da do [Catch2](https://github.com/catchorg/Catch2).
O Tipo de M√©trica Lat√™ncia (ou seja, `nanoseconds (ns)`) √© coletado.
A `lower_value` e `upper_value` est√£o um desvio padr√£o abaixo e acima da m√©dia (ou seja, `value`) respectivamente.

## ‚ûï C++ Google

O Adaptador C++ Google (`cpp_google`) espera a sa√≠da do [Google Benchmark](https://github.com/google/benchmark) no [formato JSON (ou seja, `--benchmark_format=json`)](https://github.com/google/benchmark/blob/main/docs/user_guide.md#output-formats).
O Tipo de M√©trica Lat√™ncia (ou seja, `nanoseconds (ns)`) √© coletado.
Apenas a m√©dia (ou seja, `value`) est√° dispon√≠vel. N√£o existem `lower_value` e `upper_value`.

## üï≥ Go

O Adaptador Go (`go`) √© um superconjunto de `go_bench`.

## üï≥ Go Bench

O Adaptador Go Bench (`go_bench`) espera a sa√≠da do [go test -bench](https://pkg.go.dev/testing#hdr-Benchmarks).
O Tipo de M√©trica Lat√™ncia (ou seja, `nanoseconds (ns)`) √© coletado.
Apenas a m√©dia (ou seja, `value`) est√° dispon√≠vel. N√£o existem `lower_value` e `upper_value`.

## ‚òïÔ∏è Java

O Adaptador Java (`java`) √© um superconjunto de `java_jmh`.

## ‚òïÔ∏è Java JMH

O Adaptador Java JMH (`java_jmh`) espera a sa√≠da do [Java Microbenchmark Harness (JMH)](https://github.com/openjdk/jmh) no [formato JSON (ou seja, `-rf json`)](https://github.com/openjdk/jmh/blob/master/jmh-core/src/main/java/org/openjdk/jmh/results/format/ResultFormatType.java).
Os Tipos de M√©trica `latency` e `throughput` (ou seja, `nanoseconds (ns)` e `operations / second (ops/sec)`) podem ser coletados.
A `lower_value` e `upper_value` s√£o os intervalos de confian√ßa inferior e superior para a m√©dia (ou seja, `value`) respectivamente.

## üï∏ JavaScript

O Adaptador JavaScript (`js`) √© um superconjunto de `js_benchmark` e `js_time`.

## üï∏ JavaScript Benchmark

O Adaptador JavaScript Benchmark (`js_benchmark`) espera a sa√≠da do [Benchmark.js](https://github.com/bestiejs/benchmark.js).
O Tipo de M√©trica Throughput (ie `operations / second (ops/sec)`) √© coletado.
A `lower_value` e `upper_value` s√£o a margem de erro relativo abaixo e acima da mediana (ou seja, `value`) respectivamente.

## üï∏ JavaScript Time

O Adaptador JavaScript Time (`js_time`) espera a sa√≠da do [console.time](https://developer.mozilla.org/en-US/docs/Web/API/console/time)/[console.timeEnd](https://developer.mozilla.org/en-US/docs/Web/API/console/timeEnd).
O Tipo de M√©trica Lat√™ncia (ou seja, `nanoseconds (ns)`) √© coletado.
Apenas o tempo de opera√ß√£o (ou seja, `value`) est√° dispon√≠vel. N√£o existem `lower_value` e `upper_value`.

## üêç Python

O Adaptador Python (`python`) √© um superconjunto de `python_asv` e `python_pytest`.

## üêç Python ASV

O Adaptador Python ASV (`python_asv`) espera a sa√≠da da CLI [airspeed velocity](https://github.com/airspeed-velocity/asv) [asv run](https://asv.readthedocs.io/en/stable/commands.html#asv-run).
O Tipo de M√©trica Lat√™ncia (ou seja, `nanoseconds (ns)`) √© coletado.
A `lower_value` e `upper_value` s√£o o intervalo interquartil abaixo e acima da mediana (ie `value`) respectivamente.

## üêç Python Pytest

O Adaptador Python Pytest (`python_pytest`) espera a sa√≠da do [pytest-benchmark](https://github.com/ionelmc/pytest-benchmark) no [formato JSON (ou seja, `--benchmark-json results.json`)](https://pytest-benchmark.readthedocs.io/en/latest/usage.html#commandline-options).
Esta sa√≠da JSON √© salva em um arquivo, portanto, voc√™ deve usar o argumento `--file` do CLI `bencher run` para especificar esse caminho do arquivo (ou seja, `bencher run --file results.json "pipenv run pytest --benchmark-json results.json benchmarks.py"`).
O Tipo de M√©trica Lat√™ncia (ou seja, `nanoseconds (ns)`) √© coletado.

Existem duas op√ß√µes para a M√©trica:
- `mean` (default):  A `lower_value` e `upper_value` est√£o uma desvio padr√£o abaixo e acima da m√©dia (ou seja, `value`) respectivamente.
- `median`: A `lower_value` e `upper_value` est√£o um intervalo interquartil abaixo e acima da mediana (ou seja, `value`) respectivamente.

Isso pode ser especificado no subcomando <code><a href="/pt/docs/explanation/bencher-run/">bencher run</a></code> CLI com a argumento opcional `--average`.

## ‚ô¶Ô∏è Ruby

O Adaptador Ruby (`ruby`) √© um superconjunto de `ruby_benchmark`.

## ‚ô¶Ô∏è Ruby Benchmark

O Adaptador Ruby Benchmark (`ruby_benchmark`) espera a sa√≠da do [m√≥dulo Benchmark](https://github.com/ruby/benchmark) para os m√©todos `#bm`, `#bmbm`, e `#benchmark`.
Um r√≥tulo √© necess√°rio para cada benchmark.
O Tipo de M√©trica Lat√™ncia (ou seja, `nanoseconds (ns)`) √© coletado.
Apenas o valor informado (ou seja, `value`) est√° dispon√≠vel. N√£o existem `lower_value` e `upper_value`.

## ü¶Ä Rust

O Adaptador Rust (`rust`) √© um superconjunto de `rust_bench` e `rust_criterion`.

## ü¶Ä Rust Bench

O Adaptador Rust Bench (`rust_bench`) espera a sa√≠da do [libtest bench](https://doc.rust-lang.org/rustc/tests/index.html#benchmarks).
O Tipo de M√©trica Lat√™ncia (ou seja, `nanoseconds (ns)`) √© coletado.
A `lower_value` e `upper_value` s√£o o desvio abaixo e acima da mediana (ou seja, `value`) respectivamente.

## ü¶Ä Rust Criterion

O Adaptador Rust Criterion (`rust_criterion`) espera a sa√≠da do [Criterion](https://github.com/bheisler/criterion.rs).
O Tipo de M√©trica Lat√™ncia (ou seja, `nanoseconds (ns)`) √© coletado.
A `lower_value` e `upper_value` s√£o os limites inferior e superior do gradiente (se dispon√≠vel) ou da m√©dia (se n√£o) (ou seja, `value`) respectivamente.

## ü¶Ä Rust Iai

O Adaptador Rust Iai (`rust_iai`) espera a sa√≠da do [Iai](https://github.com/bheisler/iai).
Os Tipos de M√©trica `instructions`, `l1_access`, `l2_access`, `ram_access`, e `estimated_cycles` s√£o coletados.
Apenas essas medidas (ou seja, `value`) est√£o dispon√≠veis. N√£o existem medidas `lower_value` e `upper_value`.
Os Tipos de M√©trica para este adaptador n√£o s√£o criados por padr√£o para todos os projetos.
Entretanto, quando voc√™ usa este adaptador, esses Tipos de M√©trica ser√£o automaticamente criados para o seu Projeto.

<RustIaiCallgrind />

## ‚ùØ_ Shell

O Adaptador Shell (`shell`) √© um superconjunto de `shell_hyperfine`.

## ‚ùØ_Ô∏è Shell Hyperfine

O Adaptador Shell Hyperfine (`shell_hyperfine`) espera a sa√≠da do [Hyperfine](https://github.com/sharkdp/hyperfine) no [formato JSON (ou seja, `--export-json results.json`)](https://github.com/sharkdp/hyperfine/tree/master/scripts#example).
Essa sa√≠da JSON √© salva em um arquivo, portanto, voc√™ deve usar o argumento CLI do `bencher run` `--file` para especificar esse caminho de arquivo (ou seja, `bencher run --file results.json "hyperfine --export-json results.json 'sleep 0.1'"`).
A m√©trica `latency` Kind (ou seja, `nanoseconds (ns)`) √© coletada.

Existem duas op√ß√µes para a m√©trica:
- `mean` (padr√£o): O `lower_value` e `upper_value` s√£o um desvio padr√£o abaixo e acima da m√©dia (ou seja, `value`) respectivamente.
- `median`: O `lower_value` e `upper_value` s√£o os valores `min` e `max` respectivamente.

Isso pode ser especificado no subcomando CLI do <code><a href="/pt/docs/explanation/bencher-run/">bencher run</a></code> com o sinalizador opcional `--average`.

<br />
<br />

> üê∞ Parab√©ns! Voc√™ aprendeu tudo sobre adaptadores de ferramenta de benchmark! üéâ

<br/>

<h2><a href="/pt/docs/explanation/thresholds/">Continue: Limites & Alertas ‚û°</a></h2>