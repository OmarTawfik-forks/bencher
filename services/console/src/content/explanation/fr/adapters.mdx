---
title: "Adaptateurs de Benchmark"
description: "Utilisez votre harnais de benchmark de code pr√©f√©r√© avec les adaptateurs int√©gr√©s de Bencher ou utilisez un harnais de benchmark de code personnalis√© qui produit du JSON"
heading: "Adaptateurs de Harnais de Benchmark"
published: "2023-10-27T08:40:00Z"
modified: "2024-03-27T07:50:00Z"
sortOrder: 4
---

import BmfExample from "../../../chunks/explanation/bmf-example.mdx";
import BmfSchema from "../../../chunks/explanation/bmf-schema.mdx";

import RustIaiCallgrind from "../../../chunks/explanation/fr/adapter-rust-iai-callgrind.mdx";

Les adaptateurs transforment la sortie du harnais de benchmark en JSON standardis√©, Format de M√©trique Bencher (BMF).
Les adaptateurs s'ex√©cutent sur le serveur API lorsqu'un nouveau rapport est re√ßu.
Voir l'[aper√ßu du benchmarking](/fr/docs/explanation/benchmarking/) pour une explication plus approfondie.
Ils peuvent √™tre sp√©cifi√©s dans la sous-commande CLI <code><a href="/fr/docs/explanation/bencher-run/">bencher run</a></code> avec le drapeau optionnel `--adapter`.
Si aucun adaptateur n'est sp√©cifi√©, [l'adaptateur `magic`](#-magic-default) est utilis√© par d√©faut.

Il est pr√©f√©rable d'utiliser l'adaptateur le plus sp√©cifique pour votre cas d'usage.
Cela fournira √† la fois le parsing le plus pr√©cis et performant.
Par exemple, si vous analysez la sortie du bench Rust
[libtest bench](https://doc.rust-lang.org/rustc/tests/index.html#benchmarks)
vous devriez utiliser l'adaptateur `rust_bench`, et non l'adaptateur `magic` ou `rust`.
Voir notre
[page de perf de Bencher](https://bencher.dev/perf/bencher?key=true&measures=4358146b-b647-4869-9d24-bd22bb0c49b5&tab=benchmarks&testbeds=0d991aac-b241-493a-8b0f-8d41419455d2&branches=619d15ed-0fbd-4ccb-86cb-fddf3124da29&benchmarks=3525f177-fc8f-4a92-bd2f-dda7c4e15699%2C5655ed2a-3e45-4622-bdbd-39cdd9837af8%2C1db23e93-f909-40aa-bf42-838cc7ae05f5&start_time=1674777600000)
pour une bonne comparaison.

## ü™Ñ Magique <small>(par d√©faut)</small>

L'adaptateur Magique (`magic`) est un super-ensemble de tous les autres adaptateurs.
Pour cette raison, c'est l'adaptateur par d√©faut pour `bencher run`,
mais il est pr√©f√©rable de l'utiliser uniquement pour l'exploration.
Dans le CI, vous devriez utiliser l'adaptateur le plus sp√©cifique pour votre cas d'usage.

## \{...\} JSON

L'adaptateur JSON (`json`) attend du BMF JSON.
Il est parfait pour int√©grer des harnais de benchmark personnalis√©s avec Bencher.

Exemple de BMF :

<BmfExample />

Dans cet exemple, la cl√© `nom_du_benchmark` serait le nom d'un benchmark.
Les noms de benchmark peuvent √™tre n'importe quelle cha√Æne non vide jusqu'√† 1024 caract√®res.
L'objet `nom_du_benchmark` contient des slugs de type de mesure ou des UUIDs comme cl√©s.
Dans cet exemple, `latence` est le slug pour le type de mesure Latence.
Chaque projet a par d√©faut un type de mesure Latence (c'est-√†-dire `latence`) et D√©bit (c'est-√†-dire `debit`),
qui sont mesur√©s en `nanosecond (ns)` et `op√©rations / sec (ops/s)` respectivement.
L'objet de type de mesure contient une mesure avec jusqu'√† trois mesures: `value`, `lower_value`, et `upper_value`.
Les mesures `lower_value` et `upper_value` sont optionnelles,
et leur calcul est sp√©cifique au harnais de benchmark.

Dans cet exemple, l'objet du type de mesure `latence` contient les mesures suivantes :

- Une `value` de `88.0`
- Une `lower_value` de `87.42`
- Une `upper_value` de `88.88`

Si le BMF JSON est stock√© dans un fichier,
alors vous pouvez utiliser la sous-commande CLI <code><a href="/fr/docs/explanation/bencher-run/">bencher run</a></code> avec l'argument optionnel `--file` pour sp√©cifier ce chemin de fichier.
Cela fonctionne √† la fois avec une commande de benchmark (ex : `bencher run --file results.json "bencher mock > results.json"`)
et sans une commande de benchmark (ex : `bencher mock > results.json && bencher run --file results.json`).

<BmfSchema />

> üê∞ Remarque: La sous-commande CLI `bencher mock` g√©n√®re des m√©triques BMF fictives.

## #Ô∏è‚É£ C#

L'adaptateur C# (`c_sharp`) est un super-ensemble de `c_sharp_dot_net`.

## #Ô∏è‚É£ C# DotNet

L'adaptateur C# DotNet (`c_sharp_dot_net`) attend la sortie de [BenchmarkDotNet](https://github.com/dotnet/BenchmarkDotNet) au [format JSON (c'est-√†-dire `--exporters json`)](https://benchmarkdotnet.org/articles/configs/exporters.html#sample-introexportjson).
Le type de mesure `latence` (c'est-√†-dire `nanosecondes (ns)`) est recueilli.

Il y a deux options pour la mesure :
- `mean` (par d√©faut): Les `lower_value` et `upper_value` sont un √©cart-type en dessous et au-dessus de la moyenne (c'est-√†-dire `value`) respectivement.
- `median`: Les `lower_value` et `upper_value` sont un √©cart interquartile en dessous et au-dessus de la m√©diane (c'est-√†-dire `value`) respectivement.

Cela peut √™tre sp√©cifi√© dans la sous-commande CLI <code><a href="/fr/docs/explanation/bencher-run/">bencher run</a></code> avec le drapeau optionnel `--average`.

## ‚ûï C++

L'adaptateur C++ (`cpp`) est un super-ensemble de `cpp_catch2` et `cpp_google`.

## ‚ûï C++ Catch2

L'adaptateur C++ Catch2 (`cpp_catch2`) attend la sortie de [Catch2](https://github.com/catchorg/Catch2).
Le type de mesure `latence` (c'est-√†-dire `nanosecondes (ns)`) est recueilli.
Les `lower_value` et `upper_value` sont un √©cart-type en dessous et au-dessus de la moyenne (c'est-√†-dire `value`) respectivement.

## ‚ûï C++ Google

L'adaptateur C++ Google (`cpp_google`) attend la sortie de [Google Benchmark](https://github.com/google/benchmark) au [format JSON (c'est-√†-dire `--benchmark_format=json`)](https://github.com/google/benchmark/blob/main/docs/user_guide.md#output-formats).
Le type de mesure `latence` (c'est-√†-dire `nanosecondes (ns)`) est recueilli.
Seule la moyenne (c'est-√†-dire `value`) est disponible. Il n'y a pas de `lower_value` et `upper_value`.

## üï≥ Go

L'adaptateur Go (`go`) est un super-ensemble de `go_bench`.

## üï≥ Go Bench

L'adaptateur Go Bench (`go_bench`) attend la sortie de [go test -bench](https://pkg.go.dev/testing#hdr-Benchmarks).
Le type de mesure `latence` (c'est-√†-dire `nanosecondes (ns)`) est recueilli.
Seule la moyenne (c'est-√†-dire `value`) est disponible. Il n'y a pas de `lower_value` et `upper_value`.

## ‚òïÔ∏è Java

L'adaptateur Java (`java`) est un super-ensemble de `java_jmh`.

## ‚òïÔ∏è Java JMH

L'adaptateur Java JMH (`java_jmh`) attend la sortie de [Java Microbenchmark Harness (JMH)](https://github.com/openjdk/jmh) au [format JSON (c'est-√†-dire `-rf json`)](https://github.com/openjdk/jmh/blob/master/jmh-core/src/main/java/org/openjdk/jmh/results/format/ResultFormatType.java).
Les types de mesure `latence` et `debit` (c'est-√†-dire `nanosecondes (ns)` et `op√©rations / seconde (ops/sec)`) peuvent √™tre recueillis.
Les `lower_value` et `upper_value` sont les intervalles de confiance inf√©rieur et sup√©rieur pour la moyenne (c'est-√†-dire `value`) respectivement.

## üï∏ JavaScript

L'adaptateur JavaScript (`js`) est un super-ensemble de `js_benchmark` et `js_time`.

## üï∏ JavaScript Benchmark

L'adaptateur JavaScript Benchmark (`js_benchmark`) attend la sortie de [Benchmark.js](https://github.com/bestiejs/benchmark.js).
Le type de mesure `debit` (c'est-√†-dire `op√©rations / seconde (ops/sec)`) est recueilli.
Les `lower_value` et `upper_value` sont la marge d'erreur relative en dessous et au-dessus de la m√©diane (c'est-√†-dire `value`) respectivement.

## üï∏ JavaScript Time

L'adaptateur JavaScript Time (`js_time`) attend la sortie de [console.time](https://developer.mozilla.org/en-US/docs/Web/API/console/time)/[console.timeEnd](https://developer.mozilla.org/en-US/docs/Web/API/console/timeEnd).
Le type de mesure `latence` (c'est-√†-dire `nanosecondes (ns)`) est recueilli.
Seul le temps d'op√©ration (c'est-√†-dire `value`) est disponible. Il n'y a pas de `lower_value` et `upper_value`.

## üêç Python

L'adaptateur Python (`python`) est un super-ensemble de `python_asv` et `python_pytest`.

## üêç Python ASV

L'adaptateur Python ASV (`python_asv`) attend la sortie de CLI de [airspeed velocity](https://github.com/airspeed-velocity/asv) [asv run](https://asv.readthedocs.io/en/stable/commands.html#asv-run).
Le type de mesure `latence` (c'est-√†-dire `nanosecondes (ns)`) est recueilli.
Les `lower_value` et `upper_value` sont l'√©cart interquartile en dessous et au-dessus de la m√©diane (c'est-√†-dire `value`) respectivement.

## üêç Python Pytest

L'adaptateur Python Pytest (`python_pytest`) attend la sortie de [pytest-benchmark](https://github.com/ionelmc/pytest-benchmark) au [format JSON (c'est-√†-dire `--benchmark-json results.json`)](https://pytest-benchmark.readthedocs.io/en/latest/usage.html#commandline-options).
Cette sortie JSON est sauvegard√©e dans un fichier, donc vous devez utiliser l'argument `--file` de la commande CLI `bencher run` pour sp√©cifier ce chemin de fichier (c'est-√†-dire `bencher run --file results.json "pipenv run pytest --benchmark-json results.json benchmarks.py"`).
Le type de mesure `latence` (c'est-√†-dire `nanosecondes (ns)`) est recueilli.

Il y a deux options pour la mesure :
- `mean` (par d√©faut): Les `lower_value` et `upper_value` sont un √©cart-type en dessous et au-dessus de la moyenne (c'est-√†-dire `value`) respectivement.
- `median`: Les `lower_value` et `upper_value` sont un √©cart interquartile en dessous et au-dessus de la m√©diane (c'est-√†-dire `value`) respectivement.

Cela peut √™tre sp√©cifi√© dans la sous-commande CLI <code><a href="/fr/docs/explanation/bencher-run/">bencher run</a></code> avec l'argument optionnel `--average`.

## ‚ô¶Ô∏è Ruby

L'adaptateur Ruby (`ruby`) est un super-ensemble de `ruby_benchmark`.

## ‚ô¶Ô∏è Ruby Benchmark

L'adaptateur Ruby Benchmark (`ruby_benchmark`) attend la sortie du [module Benchmark](https://github.com/ruby/benchmark) pour les m√©thodes `#bm`, `#bmbm`, et `#benchmark`.
Une √©tiquette est requise pour chaque benchmark.
Le type de mesure `latence` (c'est-√†-dire `nanosecondes (ns)`) est recueilli.
Seule la valeur rapport√©e (c'est-√†-dire `value`) est disponible. Il n'y a pas de `lower_value` et `upper_value`.

## ü¶Ä Rust

L'adaptateur Rust (`rust`) est un super-ensemble de `rust_bench` et `rust_criterion`.

## ü¶Ä Rust Bench

L'adaptateur Rust Bench (`rust_bench`) attend la sortie de [libtest bench](https://doc.rust-lang.org/rustc/tests/index.html#benchmarks).
Le type de mesure `latence` (c'est-√†-dire `nanosecondes (ns)`) est recueilli.
Les `lower_value` et `upper_value` sont l'√©cart en dessous et au-dessus de la m√©diane (c'est-√†-dire `value`) respectivement.

## ü¶Ä Rust Criterion

L'adaptateur Rust Criterion (`rust_criterion`) attend la sortie de [Criterion](https://github.com/bheisler/criterion.rs).
Le type de mesure `latence` (c'est-√†-dire `nanosecondes (ns)`) est recueilli.
Les `lower_value` et `upper_value` sont les bornes inf√©rieure et sup√©rieure soit de la pente (si elle est disponible) ou de la moyenne (si ce n'est pas le cas) (c'est-√†-dire `value`) respectivement.

## ü¶Ä Rust Iai

L'adaptateur Rust Iai (`rust_iai`) attend la sortie de [Iai](https://github.com/bheisler/iai).
Les types de mesure `instructions`, `l1_acces`, `l2_acces`, `ram_acces`, et `estimated_cycles` sont recueillis.
Seules ces mesures (c'est-√†-dire `value`) sont disponibles. Il n'y a pas de mesures `lower_value` et `upper_value`.
Les types de mesure pour cet adaptateur ne sont pas cr√©√©s par d√©faut pour tous les projets.
Cependant, lorsque vous utilisez cet adaptateur, ces types de mesure seront automatiquement cr√©√©s pour votre projet.

<RustIaiCallgrind />

## ‚ùØ_ Shell

L'adaptateur de coquille (`shell`) est un sur-ensemble de `shell_hyperfine`.

## ‚ùØ_Ô∏è Shell Hyperfine

L'adaptateur de coquille Hyperfine (`shell_hyperfine`) attend la sortie [Hyperfine](https://github.com/sharkdp/hyperfine) en [format JSON (c'est-√†-dire `--export-json results.json`)](https://github.com/sharkdp/hyperfine/tree/master/scripts#exemple).
Cette sortie JSON est sauvegard√©e dans un fichier, vous devez donc utiliser l'argument CLI `bencher run` `--file` pour sp√©cifier ce chemin de fichier (c'est-√†-dire `bencher run --file results.json "hyperfine --export-json results.json 'sleep 0.1'"`).
Le type de mesure `latency` (c'est-√†-dire `nanoseconds (ns)`) est recueilli.

Il existe deux options pour la m√©trique :
- `mean` (par d√©faut) : Les valeurs `lower_value` et `upper_value` sont une d√©viation standard en dessous et au-dessus de la moyenne (c'est-√†-dire `value`), respectivement.
- `median` : Les valeurs `lower_value` et `upper_value` sont les valeurs `min` et `max`, respectivement.

Ceci peut √™tre sp√©cifi√© dans la sous-commande CLI <code><a href="/fr/docs/explanation/bencher-run/">bencher run</a></code> avec le drapeau optionnel `--average`.

<br />
<br />

> üê∞ F√©licitations! Vous avez tout appris sur les adaptateurs de harnais de benchmark! üéâ

<br/>

<h2><a href="/fr/docs/explanation/thresholds/">Continuez: Seuils & Alertes ‚û°</a></h2>